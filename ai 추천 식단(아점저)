# 1. ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜ (Colab ìµœì´ˆ 1íšŒë§Œ ì‹¤í–‰)
!pip install ipywidgets pandas numpy openpyxl xlrd==2.0.1 --quiet

# 2. ì„í¬íŠ¸
import pandas as pd
import numpy as np
import ipywidgets as widgets
from IPython.display import display, clear_output
from itertools import product
import io
import random

# 3. íƒ„ì†Œë°°ì¶œëŸ‰ DB êµ¬ì„±
EMISSION_FACTORS = {
    "1. ë†ì¥": {"ì†Œê³ ê¸°": 48.0, "ë¼ì§€ê³ ê¸°": 5.5, "ë‹­ê³ ê¸°": 4.8, "ê³„ë€": 2.5, "ìœ ì œí’ˆ": 2.0, "ìŒ€": 3.0, "ê³¼ì¼": 0.4,"ì±„ì†Œ": 0.2, "ìˆ˜ì‚°ë¬¼(ì–‘ì‹)": 3.5, "ìˆ˜ì‚°ë¬¼(ìì—°ì‚°)": 1.5},
    "2. ê³µì¥": {"ê°€ê³µ": 0.4, "ì‚´ê· /ë©¸ê· ": 0.3, "í¬ì¥": 0.2}, "3. ìœ í†µ": {"êµ­ì‚°": 0.1, "í•´ìƒìš´ì†¡": 2.0, "í•­ê³µìš´ì†¡": 25.0},
    "4. ë§¤ì¥": {"ëƒ‰ì¥/ëƒ‰ë™": 0.2, "ì¡°ëª… ë° ê¸°íƒ€ ì—ë„ˆì§€": 0.1, "ì‹í’ˆ íê¸°": 0.2},
}

def get_carbon_tags(food_name):
    tags = []; food_name_str = str(food_name)
    for stage, items in EMISSION_FACTORS.items():
        for tag in items:
            if tag in food_name_str: tags.append((stage, tag))
    if not any("ìœ í†µ" in stage for stage, _ in tags): tags.append(("3. ìœ í†µ", "êµ­ì‚°"))
    return tags

def calculate_carbon_factor(tags):
    return sum(EMISSION_FACTORS[stage].get(tag, 0) for stage, tag in tags)

# 4. ì‚¬ìš©ì ê¶Œì¥ ì„­ì·¨ëŸ‰ ê³„ì‚°
def calculate_user_targets(gender, age, height, weight, activity_level='ë³´í†µ'):
    if gender == 'ë‚¨ì„±': bmr = 10 * weight + 6.25 * height - 5 * age + 5
    else: bmr = 10 * weight + 6.25 * height - 5 * age - 161
    factors = {'ë‚®ìŒ': 1.375, 'ë³´í†µ': 1.55, 'ë†’ìŒ': 1.725}
    tdee = bmr * factors.get(activity_level, 1.55)
    return {'calories': tdee, 'carbs': (tdee * 0.4) / 4, 'protein': (tdee * 0.3) / 4, 'fat': (tdee * 0.3) / 9}

# 5. íŒŒì¼ ì½ê¸° í•¨ìˆ˜
def read_any_table(file_name, file_content):
    try: return pd.read_excel(io.BytesIO(file_content))
    except: pass
    for enc in ('cp949', 'utf-8-sig', 'utf-8'):
        try: return pd.read_csv(io.BytesIO(file_content), encoding=enc)
        except: continue
    return pd.read_csv(io.BytesIO(file_content))

# 6. AI ì‹ë‹¨ ì¶”ì²œ í•¨ìˆ˜
def recommend_meal_plan(db, targets, seed=None):
    if seed is not None:
        random.seed(seed)
        np.random.seed(seed)
    
    db = db[db['carbon_g_per_100g'] <= 4000].copy()

    if 'meal_type' not in db.columns or 'food_group' not in db.columns:
        return "ì—‘ì…€ íŒŒì¼ì— 'meal_type'ê³¼ 'food_group' ì»¬ëŸ¼ì´ í•„ìš”í•©ë‹ˆë‹¤."

    meals = ['ì•„ì¹¨', 'ì ì‹¬', 'ì €ë…']
    best_plan = None
    lowest_score = float('inf')

    for _ in range(2000):
        current_plan = {}
        total_nutrients = pd.Series(0, index=['calories', 'carbs', 'protein', 'fat', 'carbon_g_per_100g'], dtype=float) 

        for meal in meals:
            candidates = db[db['meal_type'].str.contains(meal, na=False)]
            
            staple_candidates = candidates[candidates['food_group'] == 'ì£¼ì‹']
            main_dish_candidates = candidates[candidates['food_group'].isin(['ë©”ì¸ë°˜ì°¬', 'êµ­/ì°Œê°œ', 'ìƒëŸ¬ë“œ/ë¬´ì¹¨'])]

            if main_dish_candidates.empty: continue
            
            if not staple_candidates.empty and random.random() < 0.7:
                staple_choice = staple_candidates.sample(1).iloc[0]
                staple_portion = 210
                for nutrient in total_nutrients.index:
                    total_nutrients[nutrient] += (staple_choice[nutrient] * staple_portion / 100)
                current_plan.setdefault(meal, []).append((staple_choice['food_name'], staple_portion))

            main_dish_choice = main_dish_candidates.sample(1).iloc[0]
            main_dish_portion = 150
            for nutrient in total_nutrients.index:
                total_nutrients[nutrient] += (main_dish_choice[nutrient] * main_dish_portion / 100)
            current_plan.setdefault(meal, []).append((main_dish_choice['food_name'], main_dish_portion))

        if len(current_plan) == 3:
            score = (abs(total_nutrients['calories'] - targets['calories']) * 1.0 +
                     abs(total_nutrients['carbs'] - targets['carbs']) * 0.5 +
                     abs(total_nutrients['protein'] - targets['protein']) * 0.8 +
                     abs(total_nutrients['fat'] - targets['fat']) * 0.5)
            
            if score < lowest_score:
                lowest_score = score
                best_plan = {'plan': current_plan, 'total': total_nutrients}
    
    if not best_plan:
        return "ì¡°ê±´ì— ë§ëŠ” ì‹ë‹¨ ì¡°í•©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (ë°ì´í„° ë¶€ì¡± ë˜ëŠ” ì¡°ê±´ ê³¼ë‹¤)", None

    plan_list = []
    for meal, foods in best_plan['plan'].items():
        for food_name, portion in foods:
            row = db[db['food_name'] == food_name].iloc[0]
            nutrients = row[['calories', 'carbs', 'protein', 'fat', 'carbon_g_per_100g']] * portion / 100
            plan_list.append([meal, food_name, portion] + list(nutrients))
    
    plan_df = pd.DataFrame(plan_list, columns=['ë¼ë‹ˆ', 'ìŒì‹ëª…', 'ì„­ì·¨ëŸ‰(g)', 'calories', 'carbs', 'protein', 'fat', 'carbon_g_per_100g'])

    return plan_df, best_plan['total']

# 7. UI ìœ„ì ¯
uploader = widgets.FileUpload(accept='.csv,.xlsx', multiple=False, description="DB ì—…ë¡œë“œ")
gender = widgets.Dropdown(options=['ë‚¨ì„±', 'ì—¬ì„±'], description='ì„±ë³„')
age = widgets.IntSlider(value=25, min=10, max=80, description='ë‚˜ì´')
height = widgets.IntSlider(value=170, min=140, max=200, description='í‚¤(cm)')
weight = widgets.IntSlider(value=65, min=30, max=150, description='ì²´ì¤‘(kg)')
activity = widgets.Dropdown(options=['ë‚®ìŒ', 'ë³´í†µ', 'ë†’ìŒ'], description='í™œë™ëŸ‰')
run_button = widgets.Button(description='ğŸ± AI ì‹ë‹¨ ì¶”ì²œ', button_style='success')
refresh_button = widgets.Button(description='ğŸ”„ ë‹¤ë¥¸ ì¡°í•© ë³´ê¸°', button_style='info')
output = widgets.Output()

# 8. ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
def run_recommendation(_):
    output.clear_output()
    with output:
        if not uploader.value:
            print("â— ì‹í’ˆ ë°ì´í„° íŒŒì¼ì„ ë¨¼ì € ì—…ë¡œë“œí•˜ì„¸ìš”."); return
        content = list(uploader.value.values())[0]['content']
        df = read_any_table("file", content)

        rename_map = {'ì‹í’ˆëª…': 'food_name', 'ì—ë„ˆì§€(kcal)': 'calories', 'ì—ë„ˆì§€(ã‰)': 'calories', 'íƒ„ìˆ˜í™”ë¬¼(g)': 'carbs',
                      'ë‹¨ë°±ì§ˆ(g)': 'protein', 'ì§€ë°©(g)': 'fat', 'meal_type': 'meal_type', 'food_group': 'food_group'}
        df.rename(columns={k: v for k, v in rename_map.items() if k in df.columns}, inplace=True)
        
        if 'food_name' not in df.columns:
            print("â— 'ì‹í’ˆëª…' ì»¬ëŸ¼ì´ í•„ìš”í•©ë‹ˆë‹¤."); return
            
        df.drop_duplicates(subset=['food_name'], inplace=True)
        for col in ['calories', 'carbs', 'protein', 'fat']:
            if col in df.columns: df[col] = pd.to_numeric(df[col], errors='coerce')
        df.fillna(0, inplace=True)
        df['carbon_tags'] = df['food_name'].apply(get_carbon_tags)
        df['carbon_factor'] = df['carbon_tags'].apply(calculate_carbon_factor)
        df['carbon_g_per_100g'] = df['carbon_factor'] * 100

        user_targets = calculate_user_targets(gender.value, age.value, height.value, weight.value, activity.value)
        plan, total = recommend_meal_plan(df, user_targets, seed=np.random.randint(0, 100000))
        
        if isinstance(plan, str):
            print(f"â— {plan}"); return

        print("ğŸ‘¤ ê±´ê°• & ì €íƒ„ì†Œ AI ì‹ë‹¨ ì¶”ì²œ\n")
        
        # [ìˆ˜ì •] 'ë¼ë‹ˆ' ì»¬ëŸ¼ì˜ ìˆœì„œë¥¼ ì§ì ‘ ì§€ì •í•˜ê³  ê²½ê³  ë©”ì‹œì§€ í•´ê²°
        meal_order = ['ì•„ì¹¨', 'ì ì‹¬', 'ì €ë…']
        plan['ë¼ë‹ˆ'] = pd.Categorical(plan['ë¼ë‹ˆ'], categories=meal_order, ordered=True)
        plan.sort_values('ë¼ë‹ˆ', inplace=True)

        # ì§€ì •ëœ ìˆœì„œëŒ€ë¡œ ê·¸ë£¹í™”í•˜ì—¬ ì¶œë ¥
        for meal_type, meal_df in plan.groupby('ë¼ë‹ˆ', observed=True):
            meal_emoji = {'ì•„ì¹¨': 'â˜€ï¸', 'ì ì‹¬': 'ğŸŒ', 'ì €ë…': 'ğŸŒ™'}.get(meal_type, 'ğŸ´')
            
            food_desc_list = []
            for _, row in meal_df.iterrows():
                food_desc_list.append(f"{row['ìŒì‹ëª…']}({int(row['ì„­ì·¨ëŸ‰(g)'])})g")
            food_desc = " + ".join(food_desc_list)
            
            print(f"{meal_emoji} {meal_type}: {food_desc}")
            
        print("\nğŸ“Š ì´ ì„­ì·¨ ìš”ì•½")
        print(f"  - ì—´ëŸ‰: {total['calories']:.0f} kcal (ëª©í‘œ: {user_targets['calories']:.0f} kcal)")
        print(f"  - íƒ„ìˆ˜í™”ë¬¼: {total['carbs']:.0f} g (ëª©í‘œ: {user_targets['carbs']:.0f} g)")
        print(f"  - ë‹¨ë°±ì§ˆ: {total['protein']:.0f} g (ëª©í‘œ: {user_targets['protein']:.0f} g)")
        print(f"  - ì§€ë°©: {total['fat']:.0f} g (ëª©í‘œ: {user_targets['fat']:.0f} g)")
        print(f"  - íƒ„ì†Œë°°ì¶œëŸ‰: {total['carbon_g_per_100g'] / 1000:.2f} kg COâ‚‚e")

# 9. ë²„íŠ¼ ì—°ê²° ë° UI ì¶œë ¥
run_button.on_click(run_recommendation)
refresh_button.on_click(run_recommendation)
ui = widgets.VBox([
    widgets.HTML("<h3>ğŸ€ ê±´ê°• & ì €íƒ„ì†Œ AI ì‹ë‹¨ ì¶”ì²œê¸°</h3>"),
    uploader, gender, age, height, weight, activity,
    widgets.HBox([run_button, refresh_button]),
    output
])
display(ui)
